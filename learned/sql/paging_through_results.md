# Paging Through Results

https://use-the-index-luke.com/ja/sql/partial-results/fetch-next-page
https://qiita.com/madilloar/items/b4e786a932ef9d4551b9
https://qiita.com/madilloar/items/5625e61cf3e348d08ef8

## 2022-10-26

最初のN件のみを選択するクエリを実装できたら、次ページ移行を取り出すクエリも必要になる。
前のページをどのようにスキップするかが重要。

2つの方法が考えられる。
1. オフセット
    - 先頭から行に番号を付けて、必要なページよりも前の行番号のデータをフィルタする方法
2. シーク
    - 全ページの最後のエントリを検索し、それ以降の必要な行を読み出す方法

### オフセット

>MySQLとPostgreSQLは、最初のN行のみを選択するクエリで、始めの何行を切り捨てるか指定するのに、offset句が用意されています。 その後にlimit句が適用されます。

```sql
SELECT *
  FROM sales
 ORDER BY sale_date DESC
 LIMIT 10 OFFSET 10
```

必要なページにたどり着くため、オフセットを指定するだけで良い。
- 必要なページにたどり着くまでに、最初からそこまでの全ての行を数える必要があるため、後のページになればなるほど応答が悪くなる
- 順序付けはクエリが呼び出される度にやり直されるため、新しいデータが挿入されるとページがずれる


### シーク

- 前ページの最終行をキーにして、次ページの問い合わせを行う
    - **ページの区切りに前のページの値を使う**
    - **全ページの最後のエントリの1つあとにくるべき値を探索する**
        - WHERE句で表現する
    - シーク法では既に表示した値を選択しなくて済む
    - そのため、後のページでも応答は悪くならない
- 任意のページを表示するのが面倒
    - ページ境界のキーを調べてからでないとページジャンプできない
    - オフセット法はoffsetの行を指定すればよい
- **前ページの最終行**をキーにして次ページを決めるため、sqlが複雑になる
- **order by句にはユニークキー(もしくはプライマリキー)を含める必要がある**
    - **ページ境界を判定するためにレコードがユニークになっている必要があるため**
- 表示の順序を変えるた際には、全ての比較条件とソート処理を逆にする必要がある

```sql
SELECT *
  FROM sales
 WHERE sale_date < ?
 ORDER BY sale_date DESC
 FETCH FIRST 10 ROWS ONLY
```

1日に売上は 1回しかないとすると、
`SALE_DATE`は一意なキーとなる。
**ある日のあとの売上を選択したいとき**には、降順のソートになるので`<`の条件にする。

オフセットで使った行番号の代わりに、**下限を指定するのに前のページの最後の値**を使う。

>ページングの際は、並べ替えの順序は確定的である必要があります。
機能的には「最新の日付が最初」で並べ替えるというだけの仕様でも、我々開発者としては、order byが行の順序を確定的に するのを確実にしておかねばなりません。そのために、行の順序を確定的にする任意の列をorder by句に追加する必要があるでしょう。

>ページングの際は、並べ替えの順序は確定的である必要があります。
>Important
Paging requires a deterministic sort order.

「確定的」とはどういう意味で使っている？
並び替えの順序が確定的
行の順序を確定的にする。
